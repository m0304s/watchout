# 코드 컨벤션

## 1. 백엔드 코드 컨벤션

### 1.1 DTO (Data Transfer Object)

#### DTO 명명 규칙
- **첫글자 대문자** 사용
- **접미사**: `Request`, `Response` 사용

```java
// 좋은 예
public class UserRequestDto {
    private String userName;
    private String email;
}

public class UserResponseDto {
    private Long userId;
    private String userName;
    private String email;
}

// 나쁜 예
public class userRequest {        // 첫글자 소문자
    private String userName;
}

public class UserDto {            // 접미사 없음
    private String userName;
}
```

#### DTO ↔ Entity 변환
- **`toEntity`, `fromEntity` 모두 DTO에 작성**

```java
// UserRequestDto.java
public class UserRequestDto {
    private String userName;
    private String email;
    
    // DTO → Entity 변환
    public User toEntity() {
        return User.builder()
                .userName(this.userName)
                .email(this.email)
                .build();
    }
}

// UserResponseDto.java
public class UserResponseDto {
    private Long userId;
    private String userName;
    private String email;
    
    // Entity → DTO 변환
    public static UserResponseDto fromEntity(User user) {
        return UserResponseDto.builder()
                .userId(user.getUserId())
                .userName(user.getUserName())
                .email(user.getEmail())
                .build();
    }
}
```

### 1.2 페이징 (Paging)

#### 페이징 규칙
- **시작 페이지**: 0부터 시작
- **기본값**: pageNum=0, display=10

```java
// Controller에서 페이징 파라미터 받기
@GetMapping("/posts")
public ResponseEntity<Page<PostResponseDto>> getPosts(
    @RequestParam(defaultValue = "0") int pageNum,
    @RequestParam(defaultValue = "30") int display
) {
    Pageable pageable = PageRequest.of(pageNum, display);
    Page<PostResponseDto> posts = postService.getPosts(pageable);
    return ResponseEntity.ok(posts);
}

// Service에서 페이징 처리
public Page<PostResponseDto> getPosts(Pageable pageable) {
    Page<Post> posts = postRepository.findAll(pageable);
    return posts.map(PostResponseDto::fromEntity);
}
```

### 1.3 Controller 메서드명

#### RESTful API 메서드명 규칙

| 기능 | HTTP 메서드 | 메서드 이름 예시 |
|------|-------------|------------------|
| 목록 조회 | GET `/posts` | `getPosts()` |
| 단건 조회 | GET `/posts/{id}` | `getPost(Long id)` |
| 생성 | POST `/posts` | `createPost(PostRequestDto dto)` |
| 수정 | PUT/PATCH `/posts/{id}` | `updatePost(Long id, PostRequestDto dto)` |
| 삭제 | DELETE `/posts/{id}` | `deletePost(Long id)` |

#### Controller 예시

```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    
    // 목록 조회
    @GetMapping
    public ResponseEntity<Page<PostResponseDto>> getPosts(
        @RequestParam(defaultValue = "0") int pageNum,
        @RequestParam(defaultValue = "30") int display
    ) {
        Pageable pageable = PageRequest.of(pageNum, display);
        Page<PostResponseDto> posts = postService.getPosts(pageable);
        return ResponseEntity.ok(posts);
    }
    
    // 단건 조회
    @GetMapping("/{id}")
    public ResponseEntity<PostResponseDto> getPost(@PathVariable Long id) {
        PostResponseDto post = postService.getPost(id);
        return ResponseEntity.ok(post);
    }
    
    // 생성
    @PostMapping
    public ResponseEntity<PostResponseDto> createPost(
        @RequestBody PostRequestDto dto,
        @AuthenticationPrincipal Object principal
    ) {
        String userUuid = principal.toString();
        PostResponseDto post = postService.createPost(dto, userUuid);
        return ResponseEntity.ok(post);
    }
    
    // 수정
    @PutMapping("/{id}")
    public ResponseEntity<PostResponseDto> updatePost(
        @PathVariable Long id,
        @RequestBody PostRequestDto dto,
        @AuthenticationPrincipal Object principal
    ) {
        String userUuid = principal.toString();
        PostResponseDto post = postService.updatePost(id, dto, userUuid);
        return ResponseEntity.ok(post);
    }
    
    // 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletePost(
        @PathVariable Long id,
        @AuthenticationPrincipal Object principal
    ) {
        String userUuid = principal.toString();
        postService.deletePost(id, userUuid);
        return ResponseEntity.noContent().build();
    }
}
```

## 2. 프론트엔드 코드 컨벤션

### 2.1 폴더 구조 및 네이밍

#### 폴더 네이밍
- **폴더 안에 `index.js`가 없으면 `소문자`** 사용
- **의미있는 이름** 사용

```
components/
├── mainpage/           # 소문자 (index.js 없음)
│   ├── StatusModal.tsx
│   └── Character.tsx
├── header/             # 소문자 (index.js 없음)
│   └── Header.tsx
└── common/             # 소문자 (index.js 없음)
    └── Button.tsx
```

### 2.2 파일 네이밍

#### Page Component 파일
- **`pages` 폴더에 포함된 라우팅 페이지 컴포넌트**는 `___Page.js` 형식
- **PascalCase** 사용

```
pages/
├── MainPage.tsx
├── SearchPage.tsx
├── LoginPage.tsx
└── ProfilePage.tsx
```

#### Component 파일
- **PascalCase** 사용
- **명확한 기능을 나타내는 이름** 사용

```
components/
├── Header.tsx
├── PopUpNews.tsx
├── StatusModal.tsx
├── Character.tsx
└── NavigationBar.tsx
```

#### Component 이외의 파일
- **camelCase** 사용

```
utils/
├── fetchApi.ts
├── auth.ts
├── validation.ts
└── constants.ts
```

#### 스타일시트 파일 (CSS)
- **적용할 파일명과 동일하게** 작성

```
components/
├── Header.tsx
├── Header.css
├── PopUpNews.tsx
└── PopUpNews.css
```

### 2.3 변수 네이밍

> ⚠️ **변수명 축약하기 보다는 직관적으로 짓기**
> 
> 예시: `button` ⭕ `btn` ❌

#### 기본 변수
- **camelCase** 사용
- **영어 대소문자, 숫자** 사용
- **직관적인 이름** 사용 (축약 금지)

```javascript
// 좋은 예
const isLoggedIn = false;
const userList = [];
const button = document.querySelector('button');
const apiResponse = {};

// 나쁜 예
const isLog = false;        // 축약 사용
const list2 = [];           // 의미없는 숫자
const btn = document.querySelector('button'); // 축약 사용
```

#### Boolean 변수
- **`is` 접두사** 사용

```javascript
// 좋은 예
const isLoggedIn = false;
const isOpen = true;
const isLoading = false;
const isVisible = true;
const hasPermission = true;

// 나쁜 예
const loggedIn = false;     // is 접두사 없음
const open = true;          // is 접두사 없음
```

### 2.4 상수 (Constants)
- **대문자**로만 작성
- **여러 단어는 언더스코어(_)**로 구분

```javascript
// 좋은 예
const API_URL = 'https://api.example.com';
const BASE_URL = 'https://example.com';
const MAX_RETRY_COUNT = 3;
const DEFAULT_PAGE_SIZE = 10;
const USER_ROLES = {
  ADMIN: 'admin',
  USER: 'user'
};

// 나쁜 예
const apiUrl = 'https://api.example.com';  // camelCase 사용
const baseUrl = 'https://example.com';     // camelCase 사용
```

### 2.5 함수 네이밍

#### Event Handler 함수
- **handle + Event** 형식
- **camelCase** 사용
- **여러 이벤트 함수가 있을 경우 기능을 유추할 수 있는 단어 추가**

```javascript
// 좋은 예
const handleClick = () => {};
const handleSubmit = () => {};
const handleSubmitClick = () => {};  // 제출 버튼 클릭
const handleResetClick = () => {};   // 리셋 버튼 클릭
const handleInputChange = () => {};
const handleFormSubmit = () => {};

// 나쁜 예
const click = () => {};              // handle 접두사 없음
const submit = () => {};             // handle 접두사 없음
const onClick = () => {};            // 이벤트명과 혼동
```

#### 유틸 함수
- **camelCase** 사용
- **동사로 시작**

```javascript
// 좋은 예
const fetchUserData = () => {};
const validateEmail = () => {};
const formatDate = () => {};
const calculateTotal = () => {};

// 나쁜 예
const userData = () => {};           // 동사 없음
const email = () => {};              // 동사 없음
```

### 2.6 Props 네이밍
- **camelCase** 사용
- **Component는 PascalCase** 사용

```javascript
// 좋은 예
<Foo
  userName="hello"
  phoneNumber={12345678}
  isVisible={true}
  Component={SomeComponent}
  onButtonClick={handleClick}
/>

// 나쁜 예
<Foo
  UserName="hello"           // PascalCase 사용
  phone_number={12345678}    // snake_case 사용
  is_visible={true}          // snake_case 사용
  component={SomeComponent}  // camelCase 사용 (Component는 예외)
/>
```

## 3. 일반적인 네이밍 컨벤션

### 3.1 변수명
- **camelCase** 사용
- 의미있는 이름 사용
- 약어 사용 금지

```javascript
// 좋은 예
const userName = "홍길동";
const userAge = 25;
const isLoggedIn = true;

// 나쁜 예
const un = "홍길동";
const ua = 25;
const il = true;
```

### 3.2 함수명
- **camelCase** 사용
- 동사로 시작
- 기능을 명확히 표현

```javascript
// 좋은 예
function getUserInfo() {}
function validateEmail() {}
function handleSubmit() {}

// 나쁜 예
function get() {}
function check() {}
function do() {}
```

### 3.3 상수명
- **UPPER_SNAKE_CASE** 사용

```javascript
// 좋은 예
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = "https://api.example.com";
const DEFAULT_PAGE_SIZE = 10;
```

### 3.4 컴포넌트명
- **PascalCase** 사용
- 명사로 시작

```javascript
// 좋은 예
const UserProfile = () => {};
const NavigationBar = () => {};
const ProductCard = () => {};

// 나쁜 예
const userProfile = () => {};
const navBar = () => {};
```

## 4. 파일 구조

### 4.1 폴더 구조
```
src/
├── components/          # 재사용 가능한 컴포넌트
├── pages/              # 페이지 컴포넌트
├── hooks/              # 커스텀 훅
├── utils/              # 유틸리티 함수
├── services/           # API 호출 함수
├── types/              # TypeScript 타입 정의
├── constants/          # 상수 정의
└── styles/             # 스타일 파일
```

### 4.2 파일명
- **kebab-case** 사용
- 컴포넌트 파일은 **PascalCase** 사용

```
// 좋은 예
user-profile.jsx
api-service.js
user-types.ts
UserProfile.jsx

// 나쁜 예
userProfile.jsx
apiService.js
userTypes.ts
user-profile.jsx
```

## 5. 코드 스타일

### 5.1 들여쓰기
- **2칸 공백** 사용
- 탭 사용 금지

### 5.2 세미콜론
- **항상 사용**

```javascript
// 좋은 예
const name = "홍길동";
const age = 25;

// 나쁜 예
const name = "홍길동"
const age = 25
```

### 5.3 따옴표
- **작은따옴표(')** 사용

```javascript
// 좋은 예
const message = 'Hello World';
const apiUrl = 'https://api.example.com';

// 나쁜 예
const message = "Hello World";
const apiUrl = "https://api.example.com";
```

### 5.4 중괄호
- **K&R 스타일** 사용

```javascript
// 좋은 예
if (condition) {
  // 코드
}

function myFunction() {
  // 코드
}

// 나쁜 예
if (condition)
{
  // 코드
}

function myFunction()
{
  // 코드
}
```

## 6. 주석 규칙

### 6.1 함수 주석
- JSDoc 형식 사용

```javascript
/**
 * 사용자 정보를 가져오는 함수
 * @param {string} userId - 사용자 ID
 * @returns {Promise<Object>} 사용자 정보 객체
 */
async function getUserInfo(userId) {
  // 구현
}
```

### 6.2 인라인 주석
- 복잡한 로직에만 사용
- 한 줄로 작성

```javascript
// API 응답 데이터를 정규화
const normalizedData = response.data.map(item => ({
  id: item.user_id,
  name: item.user_name
}));
```

## 7. Import/Export 규칙

### 7.1 Import 순서
1. 외부 라이브러리
2. 내부 모듈 (절대 경로)
3. 상대 경로 모듈

```javascript
// 외부 라이브러리
import React from 'react';
import axios from 'axios';

// 내부 모듈
import { API_BASE_URL } from '@/constants/api';
import { UserType } from '@/types/user';

// 상대 경로
import './UserProfile.css';
import { validateEmail } from '../utils/validation';
```

### 7.2 Export 규칙
- **Named Export** 우선 사용
- Default Export는 컴포넌트에만 사용

```javascript
// Named Export (권장)
export const getUserInfo = () => {};
export const validateEmail = () => {};

// Default Export (컴포넌트만)
export default UserProfile;
```

## 8. 에러 처리

### 8.1 Try-Catch 사용
- 비동기 함수에서 필수 사용

```javascript
async function fetchUserData(userId) {
  try {
    const response = await api.getUser(userId);
    return response.data;
  } catch (error) {
    console.error('사용자 데이터 조회 실패:', error);
    throw error;
  }
}
```

### 8.2 에러 메시지
- 사용자 친화적인 메시지 사용
- 한글로 작성

```javascript
// 좋은 예
throw new Error('사용자 정보를 찾을 수 없습니다.');

// 나쁜 예
throw new Error('User not found');
```

## 9. 성능 최적화

### 9.1 React 최적화
- `React.memo` 적절히 사용
- `useMemo`, `useCallback` 남용 금지

```javascript
// 좋은 예
const ExpensiveComponent = React.memo(({ data }) => {
  const processedData = useMemo(() => {
    return data.map(item => processItem(item));
  }, [data]);

  return <div>{processedData}</div>;
});
```

### 9.2 불필요한 리렌더링 방지
- 의존성 배열 정확히 설정

```javascript
// 좋은 예
useEffect(() => {
  fetchData();
}, [userId]); // userId가 변경될 때만 실행

// 나쁜 예
useEffect(() => {
  fetchData();
}, []); // 빈 배열로 인한 의도치 않은 동작
```

## 10. 보안 규칙

### 10.1 민감한 정보
- 하드코딩 금지
- 환경변수 사용

```javascript
// 좋은 예
const apiKey = process.env.REACT_APP_API_KEY;

// 나쁜 예
const apiKey = "sk-1234567890abcdef";
```

### 10.2 XSS 방지
- 사용자 입력 검증 필수
- `dangerouslySetInnerHTML` 사용 금지

```javascript
// 좋은 예
const sanitizedContent = DOMPurify.sanitize(userInput);

// 나쁜 예
<div dangerouslySetInnerHTML={{ __html: userInput }} />
```
