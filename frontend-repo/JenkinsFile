pipeline {
    agent any

    parameters {
        string(name: 'GIT_REF', defaultValue: '', description: 'refs/heads/<branch>')
    }

    environment {
        DOCKER_IMAGE_NAME  = "watchout/frontend-app"
        TEST_CONTAINER     = "watchout-fe-test"
        PROD_CONTAINER     = "watchout-fe-prod"

        // Ïª®ÌÖåÏù¥ÎÑà Í∞Ñ ÌÜµÏã†ÏùÑ ÏúÑÌïú ÎÑ§Ìä∏ÏõåÌÅ¨ Ïù¥Î¶Ñ
        TEST_NETWORK       = "test-network"
        PROD_NETWORK       = "prod-network"

        TEST_PORT          = "8444" // ÌÖåÏä§Ìä∏Ïö© HTTP Ìè¨Ìä∏
        TEST_SSL_PORT      = "8443" // ÌÖåÏä§Ìä∏Ïö© HTTPS Ìè¨Ìä∏
        PROD_PORT          = "80"   // Ïö¥ÏòÅÏö© HTTP Ìè¨Ìä∏
        PROD_SSL_PORT      = "443"  // Ïö¥ÏòÅÏö© HTTPS Ìè¨Ìä∏

        // Ìò∏Ïä§Ìä∏ ÏÑúÎ≤ÑÏóê Ï†ÄÏû•Îêú SSL Ïù∏Ï¶ùÏÑú Í≤ΩÎ°ú
        CERT_PATH          = "/etc/letsencrypt/live/j13e102.p.ssafy.io"
    }

    stages {
        stage('Determine Branch') {
            steps {
                script {
                    env.ACTUAL_BRANCH = params.GIT_REF.replaceFirst(/^refs\/heads\//, '')
                    echo "‚ñ∂ Deploy branch: ${env.ACTUAL_BRANCH}"
                    echo "‚ñ∂ API URL from Jenkins Global Settings: ${env.VITE_API_BASE_URL}"
                }
            }
        }

        stage('Run PR-Agent Review') {
            when { expression { env.gitlabMergeRequestIid != null } }
            steps {
                script {
                    def mergeRequestUrl = "${env.gitlabSourceRepoHttpUrl}/-/merge_requests/${env.gitlabMergeRequestIid}"
                    
                    echo "ü§ñ Starting PR-Agent for MR: ${mergeRequestUrl}"

                    withCredentials([
                        string(credentialsId: 'gitlab-token', variable: 'GITLAB_TOKEN'),
                        string(credentialsId: 'gemini-api-key', variable: 'GEMINI_KEY')
                    ]) {
                        echo "‚ñ∂ Requesting code review..."
                        sh """
                            docker run --rm \\
                                -e GIT_PROVIDER="gitlab" \\
                                -e GITLAB_URL="https://lab.ssafy.com" \\
                                -e GITLAB_TOKEN="${GITLAB_TOKEN}" \\
                                -e GOOGLE_API_KEY="${GEMINI_KEY}" \\
                                -e MODEL="gemini/gemini-1.5-pro-latest" \\
                                -e PR_URL="${mergeRequestUrl}" \\
                                pr-agent/pr-agent:latest \\
                                review --pr_reviewer.extra_instructions="Answer in Korean"
                        """
                    }
                }
            }
        }

        stage('Prepare Networks') {
            steps {
                // Docker ÎÑ§Ìä∏ÏõåÌÅ¨Í∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ±Ìï©ÎãàÎã§.
                sh """
                    docker network create ${TEST_NETWORK} || true
                    docker network create ${PROD_NETWORK} || true
                """
            }
        }

        stage('Deploy to Test Env') {
            when { expression { env.ACTUAL_BRANCH == 'dev-fe' } }
            steps {
                dir('frontend-repo') {
                    script {
                        def tag = "${DOCKER_IMAGE_NAME}:test-${BUILD_NUMBER}"
                        echo "üê≥ Building TEST image ${tag}"

                        sh """
                            docker build \\
                                --build-arg ENV=test \\
                                --build-arg VITE_API_BASE_URL="${env.VITE_API_BASE_URL}" \\
                                -t ${tag} .
                        """

                        echo "üöÄ Running TEST container ${TEST_CONTAINER}"
                        sh """
                            docker rm -f ${TEST_CONTAINER} || true
                            docker run -d \\
                                --name ${TEST_CONTAINER} \\
                                --network ${TEST_NETWORK} \\
                                -p ${TEST_PORT}:80 \\
                                -p ${TEST_SSL_PORT}:443 \\
                                -v ${CERT_PATH}/fullchain.pem:/etc/nginx/certs/fullchain.pem:ro \\
                                -v ${CERT_PATH}/privkey.pem:/etc/nginx/certs/privkey.pem:ro \\
                                ${tag}
                        """
                    }
                }
            }
        }

        stage('Deploy to Prod Env') {
            when { expression { env.ACTUAL_BRANCH == 'main-fe' } }
            steps {
                dir('frontend-repo') {
                    script {
                        def tag = "${DOCKER_IMAGE_NAME}:prod-${BUILD_NUMBER}"
                        echo "üê≥ Building PROD image ${tag}"

                        sh """
                            docker build \\
                                --build-arg ENV=prod \\
                                --build-arg VITE_API_BASE_URL="${env.VITE_API_BASE_URL}" \\
                                -t ${tag} .
                        """

                        echo "üöÄ Running PROD container ${PROD_CONTAINER}"
                        sh """
                            docker rm -f ${PROD_CONTAINER} || true
                            docker run -d \\
                                --name ${PROD_CONTAINER} \\
                                --network ${PROD_NETWORK} \\
                                -p ${PROD_PORT}:80 \\
                                -p ${PROD_SSL_PORT}:443 \\
                                -v ${CERT_PATH}/fullchain.pem:/etc/nginx/certs/fullchain.pem:ro \\
                                -v ${CERT_PATH}/privkey.pem:/etc/nginx/certs/privkey.pem:ro \\
                                ${tag}
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            echo "üì¶ Frontend pipeline finished with status: ${currentBuild.currentResult}"
        }
    }
}